"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonceUpdateFilter = exports.ReplacedClassFilter = exports.DeclaredClassFilter = exports.DeployedContractFilter = exports.DeclaredContractFilter = exports.StorageDiffFilter = exports.StateUpdateFilter = exports.L2ToL1MessageFilter = exports.EventFilter = exports.DeployAccountTransactionFilter = exports.L1HandlerTransactionFilter = exports.DeclareTransactionFilter = exports.DeployTransactionFilter = exports.InvokeV1TransactionFilter = exports.InvokeV0TransactionFilter = exports.AnyTransactionFilter = exports.TransactionFilter = exports.FilterBuilder = exports.Filter = void 0;
const proto_1 = require("./proto");
/**
 * Helper functions to create StarkNet data filters.
 */
exports.Filter = {
    /**
     * Creates the root filter object.
     */
    create: () => new FilterBuilder(),
    /**
     * Creates a transaction filter.
     */
    transaction: () => new TransactionFilter(),
    /**
     * Creates an event filter.
     */
    event: () => new EventFilter(),
    /**
     * Creates an L2 to L1 message filter.
     */
    message: () => new L2ToL1MessageFilter(),
    /**
     * Creates a new state update filter.
     */
    stateUpdate: () => new StateUpdateFilter(),
};
class FilterBuilder {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.Filter();
    }
    /**
     * Include header in the returned data.
     *
     * If the `weak` flag is set, the block header will be included only if any
     * other filter matches.
     */
    withHeader(args) {
        const { weak } = args ?? {};
        this.inner.header = { weak };
        return this;
    }
    /**
     * Include transaction data. Use an empty filter to return all transactions.
     */
    addTransaction(filterOrBuilder) {
        this.inner.transactions.push(createFilter(filterOrBuilder, () => new TransactionFilter()));
        return this;
    }
    /**
     * Include event data. Use an empty filter to include all events.
     */
    addEvent(filterOrBuilder) {
        this.inner.events.push(createFilter(filterOrBuilder, () => new EventFilter()));
        return this;
    }
    /**
     * Include messages from L2 to L1. Use an empty filter to include all messages.
     */
    addMessage(filterOrBuilder) {
        this.inner.messages.push(createFilter(filterOrBuilder, () => new L2ToL1MessageFilter()));
        return this;
    }
    /**
     * Include state updates.
     */
    withStateUpdate(filterOrBuilder) {
        this.inner.stateUpdate = createFilter(filterOrBuilder, () => new StateUpdateFilter());
        return this;
    }
    /**
     * Returns the filter in encoded form, ready to be added to a request.
     */
    encode() {
        return proto_1.v1alpha2.Filter.encode(this.inner).finish();
    }
    /**
     * Returns the filter as a plain object.
     */
    toObject() {
        return this.inner;
    }
}
exports.FilterBuilder = FilterBuilder;
class TransactionFilter {
    /**
     * Includes any transaction type.
     */
    any() {
        return new AnyTransactionFilter();
    }
    /**
     * Include invoke transactions, V0
     */
    invokeV0() {
        return new InvokeV0TransactionFilter();
    }
    /**
     * Include invoke transactions, V1
     */
    invokeV1() {
        return new InvokeV1TransactionFilter();
    }
    /**
     * Include deploy transactions
     */
    deploy() {
        return new DeployTransactionFilter();
    }
    /**
     * Include declare transactions
     */
    declare() {
        return new DeclareTransactionFilter();
    }
    /**
     * Include l1 handler transactions
     */
    l1Handler() {
        return new L1HandlerTransactionFilter();
    }
    /**
     * Include deploy account transactions
     */
    deployAccount() {
        return new DeployAccountTransactionFilter();
    }
}
exports.TransactionFilter = TransactionFilter;
class AnyTransactionFilter {
    encode() {
        return {};
    }
}
exports.AnyTransactionFilter = AnyTransactionFilter;
class InvokeV0TransactionFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by contract address.
     */
    withContractAddress(address) {
        this.inner.contractAddress = address;
        return this;
    }
    /**
     * Filter by entry point selector.
     */
    withEntryPointSelector(selector) {
        this.inner.entryPointSelector = selector;
        return this;
    }
    /**
     * Filter by calldata prefix.
     */
    withCalldata(calldata) {
        this.inner.calldata = calldata;
        return this;
    }
    encode() {
        return {
            invokeV0: this.inner,
        };
    }
}
exports.InvokeV0TransactionFilter = InvokeV0TransactionFilter;
class InvokeV1TransactionFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by sender address.
     */
    withSenderAddress(address) {
        this.inner.senderAddress = address;
        return this;
    }
    /**
     * Filter by calldata prefix.
     */
    withCalldata(calldata) {
        this.inner.calldata = calldata;
        return this;
    }
    encode() {
        return {
            invokeV1: this.inner,
        };
    }
}
exports.InvokeV1TransactionFilter = InvokeV1TransactionFilter;
class DeployTransactionFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by contract address salt.
     */
    withContractAddressSalt(salt) {
        this.inner.contractAddressSalt = salt;
        return this;
    }
    /**
     * Filter by class hash.
     */
    withClassHash(hash) {
        this.inner.classHash = hash;
        return this;
    }
    /**
     * Filter by constructor calldata prefix.
     */
    withConstructorCalldata(calldata) {
        this.inner.constructorCalldata = calldata;
        return this;
    }
    encode() {
        return {
            deploy: this.inner,
        };
    }
}
exports.DeployTransactionFilter = DeployTransactionFilter;
class DeclareTransactionFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by sender address.
     */
    withSenderAddress(address) {
        this.inner.senderAddress = address;
        return this;
    }
    /**
     * Filter by class hash.
     */
    withClassHash(hash) {
        this.inner.classHash = hash;
        return this;
    }
    encode() {
        return {
            declare: this.inner,
        };
    }
}
exports.DeclareTransactionFilter = DeclareTransactionFilter;
class L1HandlerTransactionFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by contract address.
     */
    withContractAddress(address) {
        this.inner.contractAddress = address;
        return this;
    }
    /**
     * Filter by entry point selector.
     */
    withEntryPointSelector(selector) {
        this.inner.entryPointSelector = selector;
        return this;
    }
    /**
     * Filter by calldata prefix.
     */
    withCalldata(calldata) {
        this.inner.calldata = calldata;
        return this;
    }
    encode() {
        return {
            l1Handler: this.inner,
        };
    }
}
exports.L1HandlerTransactionFilter = L1HandlerTransactionFilter;
class DeployAccountTransactionFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by contract address salt.
     */
    withContractAddressSalt(salt) {
        this.inner.contractAddressSalt = salt;
        return this;
    }
    /**
     * Filter by class hash.
     */
    withClassHash(hash) {
        this.inner.classHash = hash;
        return this;
    }
    /**
     * Filter by constructor calldata prefix.
     */
    withConstructorCalldata(calldata) {
        this.inner.constructorCalldata = calldata;
        return this;
    }
    encode() {
        return {
            deployAccount: this.inner,
        };
    }
}
exports.DeployAccountTransactionFilter = DeployAccountTransactionFilter;
class EventFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by address emitting the event.
     */
    withFromAddress(address) {
        this.inner.fromAddress = address;
        return this;
    }
    /**
     * Filter by keys prefix.
     */
    withKeys(keys) {
        this.inner.keys = keys;
        return this;
    }
    /**
     * Filter by data prefix.
     */
    withData(data) {
        this.inner.data = data;
        return this;
    }
    /**
     * Include events emitted by reverted transactions.
     */
    withIncludeReverted(includeReverted) {
        this.inner.includeReverted = includeReverted;
        return this;
    }
    /**
     * Include the transaction that emitted the event. Defaults to true.
     */
    withIncludeTransaction(includeTransaction) {
        this.inner.includeTransaction = includeTransaction;
        return this;
    }
    /**
     * Include the receipt of the transaction that emitted the event. Defaults to true.
     */
    withIncludeReceipt(includeReceipt) {
        this.inner.includeReceipt = includeReceipt;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.EventFilter = EventFilter;
class L2ToL1MessageFilter {
    inner;
    constructor() {
        this.inner = {};
    }
    /**
     * Filter by destination address.
     */
    withToAddress(address) {
        this.inner.toAddress = address;
        return this;
    }
    /**
     * Filter by payload prefix.
     */
    withPayload(payload) {
        this.inner.payload = payload;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.L2ToL1MessageFilter = L2ToL1MessageFilter;
class StateUpdateFilter {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.StateUpdateFilter();
    }
    /**
     * Includes all storage changes that match the filter.
     */
    addStorageDiff(filterOrBuilder) {
        this.inner.storageDiffs.push(createFilter(filterOrBuilder, () => new StorageDiffFilter()));
        return this;
    }
    /**
     * Includes all declared contracts that match the filter.
     */
    addDeclaredContract(filterOrBuilder) {
        this.inner.declaredContracts.push(createFilter(filterOrBuilder, () => new DeclaredContractFilter()));
        return this;
    }
    /**
     * Includes all deployed contracts that match the filter.
     */
    addDeployedContract(filterOrBuilder) {
        this.inner.deployedContracts.push(createFilter(filterOrBuilder, () => new DeployedContractFilter()));
        return this;
    }
    /**
     * Includes all declared classes that match the filter.
     */
    addDeclaredClass(filterOrBuilder) {
        this.inner.declaredClasses.push(createFilter(filterOrBuilder, () => new DeclaredClassFilter()));
        return this;
    }
    /**
     * Includes all replaced classes that match the filter.
     */
    addReplacedClass(filterOrBuilder) {
        this.inner.replacedClasses.push(createFilter(filterOrBuilder, () => new ReplacedClassFilter()));
        return this;
    }
    /**
     * Includes all nonce updates that match the filter.
     */
    addNonceUpdate(filterOrBuilder) {
        this.inner.nonces.push(createFilter(filterOrBuilder, () => new NonceUpdateFilter()));
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.StateUpdateFilter = StateUpdateFilter;
class StorageDiffFilter {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.StorageDiffFilter();
    }
    /**
     * Filter by contract address.
     */
    withContractAddress(address) {
        this.inner.contractAddress = address;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.StorageDiffFilter = StorageDiffFilter;
class DeclaredContractFilter {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.DeclaredContractFilter();
    }
    /**
     * Filter by class hash.
     */
    withClassHash(hash) {
        this.inner.classHash = hash;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.DeclaredContractFilter = DeclaredContractFilter;
class DeployedContractFilter {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.DeployedContractFilter();
    }
    /**
     * Filter by contract address.
     */
    withContractAddress(address) {
        this.inner.contractAddress = address;
        return this;
    }
    /**
     * Filter by class hash.
     */
    withClassHash(hash) {
        this.inner.classHash = hash;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.DeployedContractFilter = DeployedContractFilter;
class DeclaredClassFilter {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.DeclaredClassFilter();
    }
    /**
     * Filter by class hash.
     */
    withCompiledClassHash(classHash) {
        this.inner.compiledClassHash = classHash;
        return this;
    }
    /**
     * Filter by class hash.
     */
    withClassHash(hash) {
        this.inner.classHash = hash;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.DeclaredClassFilter = DeclaredClassFilter;
class ReplacedClassFilter {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.ReplacedClassFilter();
    }
    /**
     * Filter by contract address.
     */
    withContractAddress(address) {
        this.inner.contractAddress = address;
        return this;
    }
    /**
     * Filter by class hash.
     */
    withClassHash(hash) {
        this.inner.classHash = hash;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.ReplacedClassFilter = ReplacedClassFilter;
class NonceUpdateFilter {
    inner;
    constructor() {
        this.inner = new proto_1.v1alpha2.NonceUpdateFilter();
    }
    /**
     * Filter by contract address.
     */
    withContractAddress(address) {
        this.inner.contractAddress = address;
        return this;
    }
    /**
     * Filter by nonce.
     */
    withNonce(nonce) {
        this.inner.nonce = nonce;
        return this;
    }
    encode() {
        return this.inner;
    }
}
exports.NonceUpdateFilter = NonceUpdateFilter;
function createFilter(filterOrBuilder, mk) {
    let filter;
    if (typeof filterOrBuilder === "function") {
        filter = filterOrBuilder(mk());
    }
    else {
        filter = filterOrBuilder;
    }
    return filter.encode();
}
//# sourceMappingURL=filter.js.map