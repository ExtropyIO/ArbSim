import { v1alpha2 } from "./proto";
/**
 * Helper functions to create StarkNet data filters.
 */
export declare const Filter: {
    /**
     * Creates the root filter object.
     */
    create: () => FilterBuilder;
    /**
     * Creates a transaction filter.
     */
    transaction: () => TransactionFilter;
    /**
     * Creates an event filter.
     */
    event: () => EventFilter;
    /**
     * Creates an L2 to L1 message filter.
     */
    message: () => L2ToL1MessageFilter;
    /**
     * Creates a new state update filter.
     */
    stateUpdate: () => StateUpdateFilter;
};
export declare class FilterBuilder {
    private inner;
    constructor();
    /**
     * Include header in the returned data.
     *
     * If the `weak` flag is set, the block header will be included only if any
     * other filter matches.
     */
    withHeader(args?: {
        weak?: boolean;
    }): this;
    /**
     * Include transaction data. Use an empty filter to return all transactions.
     */
    addTransaction(filterOrBuilder: IEncodableTransactionFilter | ((builder: TransactionFilter) => IEncodableTransactionFilter)): this;
    /**
     * Include event data. Use an empty filter to include all events.
     */
    addEvent(filterOrBuilder: IEncodable<v1alpha2.IEventFilter> | ((builder: EventFilter) => IEncodable<v1alpha2.IEventFilter>)): this;
    /**
     * Include messages from L2 to L1. Use an empty filter to include all messages.
     */
    addMessage(filterOrBuilder: IEncodable<v1alpha2.IL2ToL1MessageFilter> | ((builder: L2ToL1MessageFilter) => IEncodable<v1alpha2.IL2ToL1MessageFilter>)): this;
    /**
     * Include state updates.
     */
    withStateUpdate(filterOrBuilder: IEncodable<v1alpha2.IStateUpdateFilter> | ((filter: StateUpdateFilter) => IEncodable<v1alpha2.IStateUpdateFilter>)): this;
    /**
     * Returns the filter in encoded form, ready to be added to a request.
     */
    encode(): Uint8Array;
    /**
     * Returns the filter as a plain object.
     */
    toObject(): v1alpha2.IFilter;
}
export declare class TransactionFilter {
    /**
     * Includes any transaction type.
     */
    any(): AnyTransactionFilter;
    /**
     * Include invoke transactions, V0
     */
    invokeV0(): InvokeV0TransactionFilter;
    /**
     * Include invoke transactions, V1
     */
    invokeV1(): InvokeV1TransactionFilter;
    /**
     * Include deploy transactions
     */
    deploy(): DeployTransactionFilter;
    /**
     * Include declare transactions
     */
    declare(): DeclareTransactionFilter;
    /**
     * Include l1 handler transactions
     */
    l1Handler(): L1HandlerTransactionFilter;
    /**
     * Include deploy account transactions
     */
    deployAccount(): DeployAccountTransactionFilter;
}
export interface IEncodable<T> {
    encode(): T;
}
export declare class AnyTransactionFilter implements IEncodable<v1alpha2.ITransactionFilter> {
    encode(): v1alpha2.ITransactionFilter;
}
type IEncodableTransactionFilter = IEncodable<v1alpha2.ITransactionFilter>;
export declare class InvokeV0TransactionFilter implements IEncodableTransactionFilter {
    private inner;
    constructor();
    /**
     * Filter by contract address.
     */
    withContractAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by entry point selector.
     */
    withEntryPointSelector(selector: v1alpha2.IFieldElement): this;
    /**
     * Filter by calldata prefix.
     */
    withCalldata(calldata: v1alpha2.IFieldElement[]): this;
    encode(): v1alpha2.ITransactionFilter;
}
export declare class InvokeV1TransactionFilter implements IEncodableTransactionFilter {
    private inner;
    constructor();
    /**
     * Filter by sender address.
     */
    withSenderAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by calldata prefix.
     */
    withCalldata(calldata: v1alpha2.IFieldElement[]): this;
    encode(): v1alpha2.ITransactionFilter;
}
export declare class DeployTransactionFilter implements IEncodableTransactionFilter {
    private inner;
    constructor();
    /**
     * Filter by contract address salt.
     */
    withContractAddressSalt(salt: v1alpha2.IFieldElement): this;
    /**
     * Filter by class hash.
     */
    withClassHash(hash: v1alpha2.IFieldElement): this;
    /**
     * Filter by constructor calldata prefix.
     */
    withConstructorCalldata(calldata: v1alpha2.IFieldElement[]): this;
    encode(): v1alpha2.ITransactionFilter;
}
export declare class DeclareTransactionFilter implements IEncodableTransactionFilter {
    private inner;
    constructor();
    /**
     * Filter by sender address.
     */
    withSenderAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by class hash.
     */
    withClassHash(hash: v1alpha2.IFieldElement): this;
    encode(): v1alpha2.ITransactionFilter;
}
export declare class L1HandlerTransactionFilter implements IEncodableTransactionFilter {
    private inner;
    constructor();
    /**
     * Filter by contract address.
     */
    withContractAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by entry point selector.
     */
    withEntryPointSelector(selector: v1alpha2.IFieldElement): this;
    /**
     * Filter by calldata prefix.
     */
    withCalldata(calldata: v1alpha2.IFieldElement[]): this;
    encode(): v1alpha2.ITransactionFilter;
}
export declare class DeployAccountTransactionFilter implements IEncodableTransactionFilter {
    private inner;
    constructor();
    /**
     * Filter by contract address salt.
     */
    withContractAddressSalt(salt: v1alpha2.IFieldElement): this;
    /**
     * Filter by class hash.
     */
    withClassHash(hash: v1alpha2.IFieldElement): this;
    /**
     * Filter by constructor calldata prefix.
     */
    withConstructorCalldata(calldata: v1alpha2.IFieldElement[]): this;
    encode(): v1alpha2.ITransactionFilter;
}
export declare class EventFilter implements IEncodable<v1alpha2.IEventFilter> {
    private inner;
    constructor();
    /**
     * Filter by address emitting the event.
     */
    withFromAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by keys prefix.
     */
    withKeys(keys: v1alpha2.IFieldElement[]): this;
    /**
     * Filter by data prefix.
     */
    withData(data: v1alpha2.IFieldElement[]): this;
    /**
     * Include events emitted by reverted transactions.
     */
    withIncludeReverted(includeReverted: boolean): this;
    /**
     * Include the transaction that emitted the event. Defaults to true.
     */
    withIncludeTransaction(includeTransaction: boolean): this;
    /**
     * Include the receipt of the transaction that emitted the event. Defaults to true.
     */
    withIncludeReceipt(includeReceipt: boolean): this;
    encode(): v1alpha2.IEventFilter;
}
export declare class L2ToL1MessageFilter implements IEncodable<v1alpha2.IL2ToL1MessageFilter> {
    private inner;
    constructor();
    /**
     * Filter by destination address.
     */
    withToAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by payload prefix.
     */
    withPayload(payload: v1alpha2.IFieldElement[]): this;
    encode(): v1alpha2.IL2ToL1MessageFilter;
}
export declare class StateUpdateFilter implements IEncodable<v1alpha2.IStateUpdateFilter> {
    private inner;
    constructor();
    /**
     * Includes all storage changes that match the filter.
     */
    addStorageDiff(filterOrBuilder: IEncodable<v1alpha2.IStorageDiffFilter> | ((builder: StorageDiffFilter) => IEncodable<v1alpha2.IStorageDiffFilter>)): this;
    /**
     * Includes all declared contracts that match the filter.
     */
    addDeclaredContract(filterOrBuilder: IEncodable<v1alpha2.IDeclaredContractFilter> | ((builder: DeclaredContractFilter) => IEncodable<v1alpha2.IDeclaredContractFilter>)): this;
    /**
     * Includes all deployed contracts that match the filter.
     */
    addDeployedContract(filterOrBuilder: IEncodable<v1alpha2.IDeployedContractFilter> | ((builder: DeployedContractFilter) => IEncodable<v1alpha2.IDeployedContractFilter>)): this;
    /**
     * Includes all declared classes that match the filter.
     */
    addDeclaredClass(filterOrBuilder: IEncodable<v1alpha2.IDeclaredClassFilter> | ((builder: DeclaredClassFilter) => IEncodable<v1alpha2.IDeclaredClassFilter>)): this;
    /**
     * Includes all replaced classes that match the filter.
     */
    addReplacedClass(filterOrBuilder: IEncodable<v1alpha2.IReplacedClassFilter> | ((builder: ReplacedClassFilter) => IEncodable<v1alpha2.IReplacedClassFilter>)): this;
    /**
     * Includes all nonce updates that match the filter.
     */
    addNonceUpdate(filterOrBuilder: IEncodable<v1alpha2.INonceUpdateFilter> | ((builder: NonceUpdateFilter) => IEncodable<v1alpha2.INonceUpdateFilter>)): this;
    encode(): v1alpha2.IStateUpdateFilter;
}
export declare class StorageDiffFilter implements IEncodable<v1alpha2.IStorageDiffFilter> {
    private inner;
    constructor();
    /**
     * Filter by contract address.
     */
    withContractAddress(address: v1alpha2.IFieldElement): this;
    encode(): v1alpha2.IStorageDiffFilter;
}
export declare class DeclaredContractFilter implements IEncodable<v1alpha2.IDeclaredContractFilter> {
    private inner;
    constructor();
    /**
     * Filter by class hash.
     */
    withClassHash(hash: v1alpha2.IFieldElement): this;
    encode(): v1alpha2.IDeclaredContractFilter;
}
export declare class DeployedContractFilter implements IEncodable<v1alpha2.IDeployedContractFilter> {
    private inner;
    constructor();
    /**
     * Filter by contract address.
     */
    withContractAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by class hash.
     */
    withClassHash(hash: v1alpha2.IFieldElement): this;
    encode(): v1alpha2.IDeployedContractFilter;
}
export declare class DeclaredClassFilter implements IEncodable<v1alpha2.IDeclaredClassFilter> {
    private inner;
    constructor();
    /**
     * Filter by class hash.
     */
    withCompiledClassHash(classHash: v1alpha2.IFieldElement): this;
    /**
     * Filter by class hash.
     */
    withClassHash(hash: v1alpha2.IFieldElement): this;
    encode(): v1alpha2.IDeclaredClassFilter;
}
export declare class ReplacedClassFilter implements IEncodable<v1alpha2.IReplacedClassFilter> {
    private inner;
    constructor();
    /**
     * Filter by contract address.
     */
    withContractAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by class hash.
     */
    withClassHash(hash: v1alpha2.IFieldElement): this;
    encode(): v1alpha2.IReplacedClassFilter;
}
export declare class NonceUpdateFilter implements IEncodable<v1alpha2.INonceUpdateFilter> {
    private inner;
    constructor();
    /**
     * Filter by contract address.
     */
    withContractAddress(address: v1alpha2.IFieldElement): this;
    /**
     * Filter by nonce.
     */
    withNonce(nonce: v1alpha2.IFieldElement): this;
    encode(): v1alpha2.INonceUpdateFilter;
}
export {};
