"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultOnReconnect = exports.neverReconnect = exports.StreamClient = exports.ChannelCredentials = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const proto_1 = require("./proto");
const request_1 = require("./request");
var grpc_js_2 = require("@grpc/grpc-js");
Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function () { return grpc_js_2.ChannelCredentials; } });
const StreamService = proto_1.v1alpha2.protoDescriptor.apibara.node.v1alpha2.Stream;
// Server produces an heartbeat every 30 seconds, so we use 45 seconds as a timeout.
const MESSAGE_TIMEOUT_MS = 45000;
// Increase the default message length to 128 MiB.
const DEFAULT_MESSAGE_LENGTH = 128 * 1048576; // 128 MiB
/**
 * A client to configure and stream data.
 */
class StreamClient {
    inner;
    stream;
    stream_id;
    onReconnect;
    configuration;
    timeout;
    /**
     * Create a new `StreamClient`.
     *
     * Notice that the stream is not connected until you start iterating over it.
     * The stream should be used as an _async iterator_.
     *
     * @example
     * ```ts
     * import { StreamClient } from '@apibara/protocol'
     *
     * const client = new StreamClient({ url })
     *
     * client.configure({ filter, cursor })
     *
     * for await (const message of client) {
     *   // use message
     * }
     * ```
     */
    constructor({ url, credentials, clientOptions, token, onReconnect, timeout, }) {
        const baseCredentials = credentials ?? grpc_js_1.ChannelCredentials.createSsl();
        // only secure credentials can be composed with metadata generators.
        const credentialsWithMetadata = baseCredentials._isSecure()
            ? baseCredentials.compose(grpc_js_1.CallCredentials.createFromMetadataGenerator(createMetadataGenerator(token)))
            : baseCredentials;
        this.inner = new StreamService(url, credentialsWithMetadata, {
            "grpc.keepalive_timeout_ms": 3600000,
            "grpc.max_receive_message_length": DEFAULT_MESSAGE_LENGTH,
            ...clientOptions,
        });
        this.stream_id = 0;
        this.onReconnect = onReconnect ?? defaultOnReconnect;
        this.timeout = timeout ?? MESSAGE_TIMEOUT_MS;
    }
    /**
     * Async iterator over messages in the stream.
     */
    async *[Symbol.asyncIterator]() {
        if (!this.configuration) {
            throw new Error("StreamClient must be configured");
        }
        // connect if not connected.
        if (!this.stream) {
            this.connect();
            this._configure(this.configuration);
        }
        while (true) {
            let retryCount = 1;
            let cursor = null;
            let clock;
            try {
                // this check is to make ts happy
                if (!this.stream) {
                    throw new Error("Stream disconnected unexpectedly");
                }
                const streamIter = this.stream[Symbol.asyncIterator]();
                while (true) {
                    const timeout = new Promise((_, reject) => {
                        clock = setTimeout(() => {
                            reject(new Error("Stream timed out"));
                        }, this.timeout);
                    });
                    const message = (await Promise.race([streamIter.next(), timeout]));
                    const messageTyped = message.value;
                    clearTimeout(clock);
                    if (messageTyped.message === "heartbeat") {
                        yield messageTyped;
                    }
                    else if (messageTyped.streamId?.toString() === this.stream_id.toString()) {
                        // only return messages if they are with the most recently configured stream
                        // reset retry count on new message
                        retryCount = 1;
                        // keep cursor updated for use when reconnecting
                        if (messageTyped.data) {
                            cursor = messageTyped.data.cursor;
                        }
                        else if (messageTyped.invalidate) {
                            cursor = messageTyped.invalidate.cursor;
                        }
                        yield messageTyped;
                    }
                }
                // rome-ignore lint: any is needed for catch
            }
            catch (err) {
                clearTimeout(clock);
                const isGrpcError = Object.hasOwn(err, "code") &&
                    Object.hasOwn(err, "details") &&
                    Object.hasOwn(err, "metadata");
                // non-grpc error, so just bubble it up
                if (!isGrpcError) {
                    throw err;
                }
                const { reconnect, args } = await Promise.resolve(this.onReconnect(err, retryCount));
                retryCount += 1;
                if (!reconnect) {
                    throw err;
                }
                this.connect();
                if (args) {
                    this._configure(args);
                }
                else {
                    // use same configuration specified by user, restarting from the
                    // latest ingested batch.
                    const configuration = {
                        ...this.configuration,
                        cursor: cursor ?? this.configuration.cursor,
                    };
                    this._configure(configuration);
                }
            }
        }
    }
    /**
     * Configure the stream to return the requested data.
     *
     * The stream can be reconfigured while streaming data, the client will
     * take care of returning only data for the new configuration even if there
     * are old messages in-flight.
     */
    configure(args) {
        this.configuration = args;
        this._configure(args);
    }
    _configure(args) {
        const { filter, batchSize, cursor, finality } = args;
        this.stream_id++;
        // only send configuration if connected
        if (this.stream) {
            const builder = request_1.StreamDataRequest.create()
                .withStreamId(this.stream_id)
                .withFilter(filter);
            if (batchSize) {
                builder.withBatchSize(batchSize);
            }
            if (cursor) {
                builder.withStartingCursor(cursor);
            }
            if (finality) {
                builder.withFinality(finality);
            }
            const request = builder.encode();
            this.stream?.write(request);
        }
    }
    connect() {
        this.stream = this.inner.streamData();
        return this;
    }
}
exports.StreamClient = StreamClient;
/**
 * A `onReconnect` callback that never reconnects.
 */
function neverReconnect(_err, _retryCount) {
    return {
        reconnect: false,
    };
}
exports.neverReconnect = neverReconnect;
/**
 * A `onReconnect` callback that retries to reconnect up to 5 times.
 *
 * If the error is not an internal error, then it will not reconnect.
 * This callback awaits for `1s * retryCount` before returning.
 */
async function defaultOnReconnect(err, retryCount) {
    if (err.code !== 13) {
        return {
            reconnect: false,
        };
    }
    await new Promise((resolve) => setTimeout(resolve, retryCount * 1000));
    return {
        reconnect: retryCount < 5,
    };
}
exports.defaultOnReconnect = defaultOnReconnect;
/*
 * Returns a generator that adds the given `token` to request metadata.
 */
function createMetadataGenerator(token) {
    const metadata = new grpc_js_1.Metadata();
    if (token) {
        metadata.add("authorization", `bearer ${token}`);
    }
    return (_options, cb) => {
        cb(null, metadata);
    };
}
//# sourceMappingURL=client.js.map