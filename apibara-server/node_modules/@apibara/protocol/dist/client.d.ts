import { ChannelCredentials, ClientDuplexStream, ClientOptions, StatusObject } from "@grpc/grpc-js";
import { v1alpha2 } from "./proto";
export { ChannelCredentials, StatusObject } from "@grpc/grpc-js";
export type DataStream = ClientDuplexStream<v1alpha2.IStreamDataRequest, v1alpha2.IStreamDataResponse>;
export type ConfigureArgs = {
    /**
     * Stream filter, encoded.
     */
    filter: Uint8Array;
    /**
     * How much data in a single message.
     */
    batchSize?: number;
    /**
     * Starting cursor. This cursor is stream-specific.
     */
    cursor?: v1alpha2.ICursor | null;
    /**
     * Data finality, e.g. finalized or accepted.
     */
    finality?: v1alpha2.DataFinality | null;
};
/**
 * Reconnect callback return value.
 */
export type OnReconnectResult = {
    /**
     * If `true`, reconnects to the stream.
     */
    reconnect: boolean;
    /**
     * Stream configuration used when reconnecting.
     *
     * By default, the client uses the last configuration passed to
     * `configure` and updates the `cursor` with the most recent one.
     */
    args?: ConfigureArgs;
};
/**
 * Reconnect callback.
 */
export type OnReconnect = (err: StatusObject, retryCount: number) => Promise<OnReconnectResult> | OnReconnectResult;
export type StreamClientArgs = {
    /**
     * The stream url.
     */
    url: string;
    /**
     * Override Grpc credentials.
     *
     * Use `ChannelCredentials.createInsecure()` to disable SSL.
     */
    credentials?: ChannelCredentials;
    /**
     * Grpc client options.
     */
    clientOptions?: ClientOptions;
    /**
     * Authorization bearer token, used to authenticate with the server.
     */
    token?: string;
    /**
     * Callback to control reconnection after receiving an error from the stream.
     *
     * By default uses `defaultOnReconnect`, which only reconnects on internal grpc errors.
     */
    onReconnect?: OnReconnect;
    /**
     * Maximum time to wait for a message before timing out, in milliseconds.
     *
     * Defaults to 45 seconds.
     */
    timeout?: number;
};
/**
 * A client to configure and stream data.
 */
export declare class StreamClient {
    private readonly inner;
    private stream?;
    private stream_id;
    private onReconnect;
    private configuration?;
    private timeout;
    /**
     * Create a new `StreamClient`.
     *
     * Notice that the stream is not connected until you start iterating over it.
     * The stream should be used as an _async iterator_.
     *
     * @example
     * ```ts
     * import { StreamClient } from '@apibara/protocol'
     *
     * const client = new StreamClient({ url })
     *
     * client.configure({ filter, cursor })
     *
     * for await (const message of client) {
     *   // use message
     * }
     * ```
     */
    constructor({ url, credentials, clientOptions, token, onReconnect, timeout, }: StreamClientArgs);
    /**
     * Async iterator over messages in the stream.
     */
    [Symbol.asyncIterator](): AsyncIterator<v1alpha2.IStreamDataResponse>;
    /**
     * Configure the stream to return the requested data.
     *
     * The stream can be reconfigured while streaming data, the client will
     * take care of returning only data for the new configuration even if there
     * are old messages in-flight.
     */
    configure(args: ConfigureArgs): void;
    private _configure;
    private connect;
}
/**
 * A `onReconnect` callback that never reconnects.
 */
export declare function neverReconnect(_err: StatusObject, _retryCount: number): OnReconnectResult;
/**
 * A `onReconnect` callback that retries to reconnect up to 5 times.
 *
 * If the error is not an internal error, then it will not reconnect.
 * This callback awaits for `1s * retryCount` before returning.
 */
export declare function defaultOnReconnect(err: StatusObject, retryCount: number): Promise<OnReconnectResult>;
